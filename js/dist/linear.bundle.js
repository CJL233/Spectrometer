(()=>{function t(t){return t?[t.length,t[0].length]:[0,0]}function e(){throw"Invalid matrix Rank"}function i(e){this.value=e,this.size=t(e)}function n(){console.log("矩阵存在以下方法：\n\t\tm1.x(m2): 矩阵乘法，返回新矩阵m3=m1m2\n\t\tm1.add(m2): 矩阵加法，返回新矩阵m3=m1+m2\n\t\tm1.set(arr): 将矩阵m1的值设为二维数组arr\n\t\tm1.inv(): 对矩阵m1求逆矩阵，返回值为一个新矩阵\n\t\tm1.T(): 对矩阵m1求转置矩阵，返回值为一个新矩阵")}class s{constructor(t){this.type=s,this.size=[0,0],this.value=t,this.x=a,this.add=h}}class r{constructor(e){this.help=n,this.type=r,this.value=e,this.size=t(e),this.x=a,this.add=h,this.set=i,this.inv=o,this.T=u}toString(){return`[${this.value.map((t=>t.join(","))).join(";")}]`}}class l{constructor(e){this.help=n,this.type=l,this.value=e,this.size=t(e),this.set=i,this.T=u,this.conj=m}toString(){return`[${this.value.map((t=>t.join(","))).join(";")}]`}}function a(t){let i=this.value;if("number"==typeof t)return new this.type(i.map((e=>e.map((e=>e*t)))));this.size[1]!==t.size[0]&&e();let n=t.value,s=i.map(((t,e)=>n[0].map(((e,i)=>t.reduce(((t,e,s)=>t+e*n[s][i]),0)))));return s.length+s[0].length===2?s[0][0]:new this.type(s)}function h(t){this.size[0]===t.size[0]&&this.size[1]===t.size[1]||e();let i=this.value,n=t.value;return new this.type(i.map(((t,e)=>t.map(((t,i)=>t+n[e][i])))))}function o(){const t=this.size[0];if(Math.abs(c(this))<1e-9)return null;let e=this.value.map((t=>t.slice()));e.forEach(((i,n)=>{for(let i=0;i<t;i++)e[n].push(0);e[n][n+t]=1}));for(let i=0;i<t;i++)for(let n=i+1;n<t;n++)e[n]=new s([e[i]]).x(-e[n][i]/e[i][i]).add(new s([e[n]])).value[0];for(let i=t-1;i>0;i--)for(let t=i-1;t>=0;t--)e[t]=new s([e[i]]).x(-e[t][i]/e[i][i]).add(new s([e[t]])).value[0];for(let i=0;i<t;i++)e[i]=new s([e[i]]).x(1/e[i][i]).value[0];return e=e.map((e=>e.slice(t))),new this.type(e)}function u(){const t=this.value;return new this.type(t[0].map(((e,i)=>t.map(((e,n)=>t[n][i])))))}function m(){}function c({value:t,size:i}){return i[1]!==i[0]&&e(),3===i[0]?t[0][0]*t[1][1]*t[2][2]+t[0][1]*t[1][2]*t[2][0]+t[0][2]*t[1][0]*t[2][1]-t[0][2]*t[1][1]*t[2][0]-t[0][1]*t[1][0]*t[2][2]-t[0][0]*t[1][2]*t[2][1]:2===i[0]?t[0][0]*t[1][1]-t[0][1]*t[1][0]:0}function p({value:t,size:i}){return i[1]!==i[0]&&e(),t.reduce(((t,e,i)=>t+e[i]),0)}function f(t){let e=new Array(t).fill(0).map((e=>new Array(t).fill(0)));return e.forEach(((t,i)=>{e[i][i]=1})),new r(e)}function w(t){let e=new Array(t).fill(0).map((e=>new Array(t).fill(0)));return new r(e)}void 0===window.Matrix&&(window.Matrix=new class{constructor(){this.matrix=r,this.complex=l,this.tr=p,this.I=f,this.zero=w,this.det=c}help(){console.log("Matrix存在以下方法：\n\t\t\tmatrix(): 实矩阵对象，使用new关键字来新建\n\t\t\tcomplex(): 复矩阵对象，用new关键字来新建\n\t\t\tdet(m): 矩阵工具，求矩阵m的行列式\n\t\t\ttr(m): 矩阵工具，求矩阵m的迹\n\t\t\tI(n): 创建一个n阶单位实矩阵I")}})})();